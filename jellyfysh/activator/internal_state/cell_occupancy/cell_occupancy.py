# JeLLFysh - a Python application for all-atom event-chain Monte Carlo - https://github.com/jellyfysh
# Copyright (C) 2019, 2022 The JeLLyFysh organization
# (See the AUTHORS.md file for the full list of authors.)
#
# This file is part of JeLLyFysh.
#
# JeLLyFysh is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# JeLLyFysh is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with JeLLyFysh in the LICENSE file.
# If not, see <https://www.gnu.org/licenses/>.
#
# If you use JeLLyFysh in published work, please cite the following reference (see [Hoellmer2020] in References.bib):
# Philipp Hoellmer, Liang Qin, Michael F. Faulkner, A. C. Maggs, and Werner Krauth,
# JeLLyFysh-Version1.0 -- a Python application for all-atom event-chain Monte Carlo,
# Computer Physics Communications, Volume 253, 107168 (2020), https://doi.org/10.1016/j.cpc.2020.107168.
#
"""Module for the abstract CellOccupancy class."""
from abc import ABCMeta, abstractmethod
from typing import Iterable, Sequence, Tuple
from jellyfysh.activator.internal_state import InternalState
from jellyfysh.base.node import Node
from jellyfysh.state_handler.tree_state_handler import StateId
from .cells import Cells, Cell


class CellOccupancy(InternalState, metaclass=ABCMeta):
    """
    Abstract class for a general cell-occupancy system that maps identifiers of the global state onto cells in the
    underlying cell system.

    This class is designed to work together with the TreeStateHandler. A global state identifier is then a tuple of
    integers, where the tuple can have different lengths (see StateId in state_handler.tree_state_handler.py). This
    cell-occupancy system has a cell_level attribute that determines the length of the relevant global state identifiers
    that are stored in this internal state. All other global state identifiers are ignored.
    For the TreeStateHandler, both the extracted global state, and the extracted active global state (that are used to
    initialize and update this internal state, respectively) are sequences of branches of cnodes containing units.

    On initialization, this cell-occupancy system receives a maximum number of global state identifiers that can be
    possibly stored for each cell, and which are returned by the __getitem__ method. All additional global state
    identifiers, which would be mapped onto a cell that has reached its maximum number of occupants, are treated as
    surplus identifiers that are generated by the yield_surplus method. Note that it is also possible to choose an
    infinite upper bound on the number of occupants. In this case, there are never any surplus identifiers.

    Identifier of active units should not be stored in the cell-occupancy system itself (i.e., they should not be
    returned by the __getitem__ and yield_surplus methods), but stored separately so that they can be efficiently
    generated in the yield_active_cells method.
    """

    def __init__(self, cells: Cells, cell_level: int, maximum_number_occupants: int) -> None:
        """
        The constructor of the CellOccupancy class.

        Parameters
        ----------
        cells : activator.internal_state.cell_occupancy.cells.Cells
            The underlying cell system.
        cell_level : int
            The length of the global state identifiers which should be stored in this internal state.
        maximum_number_occupants : int
            The maximum number of allowed occupants per cell. If this number is smaller than or equal to zero, this
            class allows for an infinite number of occupants per cell.
        """
        super().__init__()
        self._cells = cells
        self._cell_level = cell_level
        self._maximum_number_occupants = maximum_number_occupants
        self._number_occupants_not_bounded = maximum_number_occupants <= 0

    @abstractmethod
    def initialize(self, extracted_global_state: Sequence[Node]) -> None:
        """
        Initialize the internal state based on the full extracted global state from the tree state handler.

        Extends the initialize method of the InternalState class. Use this method once in the beginning of the run to
        initialize the internal state. Only after a call of this method, other public methods of this class can be
        called without raising an error.

        For the tree state handler, the full extracted global state is a sequence of cnodes of all root nodes that are
        stored in the global state.

        Parameters
        ----------
        extracted_global_state : Sequence[base.node.Node]
            The full extracted global state from the tree state handler.
        """
        super().initialize(extracted_global_state)

    @abstractmethod
    def __getitem__(self, internal_state_identifier: Cell) -> Sequence[StateId]:
        """
        Return a sequence of the stored global state identifiers that are stored for the given cell.

        The number of entries in the sequence of the global state identifiers that are associated to the given cell is
        at most the maximum number of allowed occupants per cell of this cell-occupancy system. If no global state
        identifier is associated with the given cell, this method should return an empty sequence.

        If this cell-occupancy system associates more global state identifiers to the given cell than the maximum number
        of allowed occupants, surplus global state identifiers should be generated by the yield_surplus method.

        Relevant active global state identifiers that are also associated with the given cell should not be returned by
        this method.

        Parameters
        ----------
        internal_state_identifier : activator.internal_state.cell_occupancy.cells.Cell
            The cell.

        Returns
        -------
        Sequence[state_handler.tree_state_handler.StateId]
           The global state identifiers associated with the cell.
        """
        raise NotImplementedError

    @abstractmethod
    def update(self, extracted_active_global_state: Sequence[Node]) -> None:
        """
        Update the internal state based on the extracted active global state.

        Use this method to keep the internal state consistent with the global state. For the tree state handler, the
        extracted active global state is a sequence of cnodes of root cnodes where each cnode branch only contains
        active units.

        Parameters
        ----------
        extracted_active_global_state : Sequence[base.node.Node]
            The extracted active global state from the tree state handler.
        """
        raise NotImplementedError

    @abstractmethod
    def yield_surplus(self) -> Iterable[StateId]:
        """
        Generate all surplus identifiers of this cell-occupancy system.

        Surplus global state identifiers are present if the number of global state identifiers associated to any cell
        exceeds the maximum number of allowed occupants per cell. This method should generate the surplus global state
        identifiers of all cells.

        Relevant active global state identifiers should never be generated by this method.

        Yields
        ------
        state_handler.tree_state_handler.StateId
            The surplus global state identifier.
        """
        raise NotImplementedError

    @abstractmethod
    def yield_active_cells(self) -> Iterable[Tuple[Cell, StateId]]:
        """
        Generate the cells and the global state identifiers of the relevant active units on the cell-level of this
        cell-occupancy system.

        Yields
        ------
        (Cell, StateId)
            The cell, the global state identifier of the active unit.
        """
        raise NotImplementedError

    @property
    def cells(self) -> Cells:
        """
        Return the underlying cell system.

        Returns
        -------
        activator.internal_state.cell_occupancy.cells.Cells
            The underlying cell system.
        """
        return self._cells

    @property
    def cell_level(self) -> int:
        """
        Return the length of the global state identifiers of the tree state handler that are stored in this internal
        state.

        Returns
        -------
        int
            The cell level.
        """
        return self._cell_level
